\message{ !name(datenflussanalyse.tex)}
\message{ !name(datenflussanalyse.tex) !offset(-2) }
\section{Datenflußanalyse und \\Single-Assignment-Konversion}
%----------------------------------------------------------------------
Die Datenflußanalyse nach Feautrier \cite{Fea91} ist aufwendiger als die von
Banerjee, berücksichtigt aber auch die Optimierung. 

\subsection{Ansatz}
Im Gegensatz zu Banerjee werden nicht alle Abhängigkeiten gesucht,
sondern nur echte Datenflußabhängigkeiten. Daher werden nicht alle
Zugriffspaare untersucht, sondern zu jedem Lesezugriff werden alle
Schreibzugriffe als mögliche Quellen betrachtet. Der Lesezugriff ist
damit die Senke; der Typ der Abhängigkeiten ist \emph{flow}.

Durch diesen Ansatz wird die Existenz des Lesezugriffs zu einer immer
erfüllten Voraussetzung, die für das Konfliktgleichungssystem und die
Existenz der Quelle oder auch die Optimierung zusätzliche Informationen
bedeutet.

Das System aus Konfliktgleichungen, Existenzungleichungen und
Ordnungsungleichungen wird einem Tool zur parametrisierten, ganzzahlig
linearen Optimierung (z.B. PIP) in einem Aufwasch präsentiert.

Die (lokal bereits optimierten) Lösungsergebnisse werden in einem
zweiten Arbeitsgang ``gemischt''.

Resultat: für Polyeder: eindeutige Quellen je Lesezugriff.

\subsection{Single-Assignment-Konversion}
\begin{\itemize}
\item einmalige Zuweisung durch ``Umleiten'' der Schreibzugriffe in
  neue Arrays, die voll indiziert sind.
\item Wiederherstellung der Semantik durch Einsetzen der Quelle in den
  Lesezugriffen.
\end{\itemize}

\subsection{Verfahren von Feautrier:}
\textit{Konfliktgleichungssystem:} gleich Banerjee\\
\textit{Existenz-Ungleichungen:} Welche \glqq Writes \grqq schreiben den an der aktuellen Stelle gelesenen Wert? Welches \glqq Write \grqq ist das letzte? $\leftarrow$ Optimierung\\
\textit{Read-Existenz:} Kontext für die Analyse, Feautrier liefert nur optimierten True-Deps., also die Flow-Dependences.\\
\textit{Folge:} die Ordnung wird Input des Verfahrens:\\
als Ungleichungssysteme (je Fall für die lexikographiesche Ordnung eine)

\subsubsection{Beispiel}
\textit{Programmcode:}

\begin{procedure}
\SetLine
\For{$i=0$ \KwTo $n$}{
    \textbf{R:} $A[0,0] := ...$\\
    \textbf{S:} $X[i]   := A[i,0]$\\
    \For{$j=1$ \KwTo $n$}{
        \For{$k=1$ \KwTo $n$}{
            \textbf{T:} $A[i+k-1,j-1]:=...$\\
        }
    }
}
\end{procedure}

\textit{Frage:} Wer hat den Wert geschrieben, der in $\langle (i),S \rangle$ gelesen wird?\\

\textbf{S-T-Konflikt}\\
\begin{\itemize}
    \item \textit{Instanz:} $\langle (i), S \rangle$, $\langle (i^\prime, j^\prime, k^\prime), T) \rangle$

    \item \textit{Konfliktgleichungssystem:} \\
        $\begin{array}{cc}
        \left.
        \begin{array}{c@= l}
            i & i^\prime + k^\prime-1\\
            0 & j-1
        \end{array} \right\} & \Leftrightarrow
        \begin{array}{c@= l}
            k^\prime & i-i^\prime +1 \\
            j^\prime & 1
        \end{array}
        \end{array}$

        
    \item \textit{Existenzgleichungen:} nur für $i^\prime, j^\prime, k^\prime$\\
        \begin{align*}
        0 &\leq i^\prime \leq n \\
        1 &\leq j^\prime \leq n \\
        1 &\leq k^\prime \leq n
        \end{align*}
        Kontext: $0 \leq i \leq n$
    \item \textit{Ordnung:} soll $\langle ( i^\prime, j^\prime, k^\prime), T \rangle \rightarrow \langle (i), S \rangle$\\

    $(i^\prime < i) \lor \underbrace{(i^\prime = i \land \text{T textuell vor S})}_{false}$


$\begin{array}{cccccc}
i^\prime & j^\prime & k^\prime & i & n & 1  \\
-1       & 0        & -1       & 1 & 0 & 1  \\
1        & 0        & 1        & -1& 0 & -1 \\
0        & 1        & 0        & 0 & 0 & -1 \\
0        & -1       & 0        & 0 & 0 & 1  \\
1        & 0        & 0        & 0 & 0 & 0  \\
-1       & 0        & 0        & 0 & 1 & 0  \\
0        & 1        & 0        & 0 & 0 & -1 \\
0        & -1       & 0        & 0 & 1 & 0  \\
0        & 0        & 1        & 0 & 0 & -1 \\
0        & 0        & -1       & 0 & 1 & 0  \\
0        & 0        & 0        & 1 & 0 & 0  \\
0        & 0        & 0        &-1 & 1 & 0  \\
{}&{}&{}&{}&{}&{}\\
-1       & 0        & 0        & 1 & 0 &-1	
\end{array}$

Zwischenergebnis: \\$\langle (i^\prime, 1, i-i^\prime+1), T \rangle \rightarrow \langle (i), s \rangle *\\$ für $ 0 \leq i^\prime < i \leq n \text{,} 1\leq i-i^\prime + 1 \leq n \\
\text{für Kontext} 0\leq i \leq n$

\item \textit{Optimierung}\\
    gesucht: letzte (lex. größte) Instanz von T mit *, die vor $\langle (i), S \rangle$ ausgeführt wird. \\
    Lösung: $i^\prime = i-1\\
            \Rightarrow \langle (i-1,1,2), T \rangle \rightarrow \langle (i), S \rangle$ für $i \geq 1$
\end{\itemize}

\textbf{S-R-Konflikt}\\
    \begin{\itemize}
    \item $\langle (i), S \rangle \text{,} \langle(i^\prime), R \rangle$
    \item $0=i \land 0 = 0$
    \item $0 \leq i^\prime n \text{im Kontext} 0 \leq i \leq n$
    \item $i^\prime < i \lor (i^\prime = i land \text{R vor S}) \Leftrightarrow i^\prime \leq i$
    \item $i^\prime = i \\ 
        \Rightarrow \langle (i),R \rangle \rightarrow \langle (i), S \rangle \text{ für } i=0 \\
        \Rightarrow \langle (0),R \rangle \rightarrow \langle (0), S \rangle$

    \end{\itemize}
Datenfluss: \\
\begin{procedure}
    src($ \langle (i), S \rangle $) =\\ \eIf{$i=0$}{$\langle (0), R \rangle$}{$\langle (i-1,1,2),T \rangle$}
\end{procedure}

Vorsicht: Falls die Bedingungen der Schleifenindizes nicht disjunkt sind, geht die Abhängigkeit von Maximum der Quellen (bzgl. der Ausführungsordnung) aus.

%% --------------------------- CfFada -------------------------------------------------

\subsection{Verfahren via CfFada:}

CfFada heißt ausgeschrieben \glqq Controllflow based Fuzzy array dataflow\grqq.\\
Dieses weiteres Verfahren wird motiviert durch die Existenz von \glqq if-Statements \grqq , \glqq unstrukturierte Programme \grqq und die erhöte \glqq Präzision \grqq.\\
\paragraph{Idee:}
\begin{\itemize}
    \item Zusammenführen von
    \begin {\itemize}
        \item traditionellen (universell einsetzbar, ungenau) und
        \item einem Feautrier-ähnlichem Verfahren
    \end{\itemize}
    \item (Effizienz)
\end{\itemize}

\paragraph{Prinzipielles Vorgehen:}
\begin{enumerate}
    \item Konstruiere den Kontrollflußgraphen (CFG)
    \item Für jeden Zugriff a:
        \begin{\itemize}
            \item Annotiere den CFG mit den für a relevanten Relationen - unter Berücksichtigung der umgebenden Prädikaate
            \item starte mit leerer Abhängigkeitsmenge (alles bottom) und Ordnungsrelation $(=,...,=)$ bei a.
            \item durchlaufe den CFG rückwärts
            \item bei Schleifen: durchlaufe die Rückwärtskanten von innen nach außen und passe die aktuell gültige Ordnungsrelation an
            \item bei \glqq conflicting accesses \grqq : mische die neuen und alten Abhängigkeiten unter Berücksichtigung der Optimierung
        \end{\itemize}
\end{enumerate}


\paragraph{Anmerkungen:}

\begin{enumerate}
    \item Implementierung mit Omega (Presburger Arithmetik) $\rightarrow$ Genauigkeit
    \item unstrukturierte Programme $\rightarrow$ Abschätzung der Ordnungrelation
    \item vorzeitiges Analyse-Ende möglich
\end{enumerate}




\subsubsection{Beispiel zur Abhängigkeitsanalyse nach CfFada}

\textit{Programmcode:}\\

\begin{procedure}
\SetLine
\For{$i=0$ \KwTo $N$}{
    \For{$j=0$ \KwTo $N$}{
        
        \bf{3:} $A[i+j+1]$ = ... \\
        \eIf{$P$}
            {\bf{6:} $A[i+j]$ = ...\\}
            {\bf{7:} ... = $A[i+j]$}

    }
}
\end{procedure}

\textbf{Kontext}\\
Read-Statement 7\\
Operationen: $\langle (i,j), 7 \rangle$ für $0 \leq i, j \leq N$\\
\\
\textbf{Annotierung}\\
Statement 3\\
Operationen: \(\langle (i^\prime,j^\prime), 3 \rangle\) für \( \underbrace{0 \leq i^\prime, j^\prime \leq N}_{Existenz} \land \underbrace{i^\prime + j^\prime + 1 = i + j}_{Konflikt}\)
\\
\textbf{Durchlauf}\\
\begin{\itemize}
    \item {Ordnung: \(i=i^\prime \land j=j^\prime\) \\
        \(src^{(0)} = {\perp}\)\\
        \begin{\itemize}
            \item Start: 7
            \item die 4 hoch: (Kante mit Label 4)\\
                  Keine neuen Quellen\\
                  \(scr_{4}^{(1)} = \lbrace \perp \rbrace\)
            \item die 6 hoch: \\
                  \(src_{6}^{(1)} = src^{(0)} \Box W(6) = \) 
    \(\begin{cases}  \langle (i,j), 6 \rangle , & \mbox{für} p^\prime(i,j) \\
                     \perp ,                    & \mbox{sonst}
    \end{cases}  \)

            \item bei n1 Mischen:\\
                \(scr_{n1}^{(1)} = 
    \begin{cases} \langle (i,j),6 \rangle, & \mbox{für} p^\prime(i,j) \\
                  \perp,                   & \mbox{sonst} 
                \end{cases} \)

            \item die 3 hoch:\\
                  Keine neuen Quellen, da die aktuelle Ordnung \blitza Konfliktgleichung.
            \item die 13 hoch \(\Rightarrow\)

        \end{\itemize}
        }
    \item {Ordnung: \(i=i^\prime \land j^\prime < j\) \\
      \begin{\itemize}
         \item die Kanten 7, 4 bringen nichts neues.
         \item die 6 hoch: \\
           Keine neuen Quellen, da die aktuelle Ordnung \blitza Konfliktgleichung.
         \item n1: nichts neues zu mischen \(\Rightarrow\) alles bleibt
         \item die 3 hoch: \\
           \(src^{(2)} = src^{(1)} \Box W(3) = 
           \begin{cases} \langle ( i^\prime, j^\prime), 3) \rangle, & \mbox{für} i^\prime + j^\prime + 1 = i + j \land \neg P^\prime(i,j)\\
             \langle (i,j),6 \rangle , & \mbox{für} P^\prime(i,j) \\
             \perp, & \mbox{sonst}
           \end{cases} \)
      \end{\itemize}
      }
    
\end{\itemize}



\message{ !name(datenflussanalyse.tex) !offset(-250) }
