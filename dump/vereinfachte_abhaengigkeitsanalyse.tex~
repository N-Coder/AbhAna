%\newpage
%\setcounter{section}{6}
\section{Vereinfachte Abhängigkeitsanalyse}
%------------------------------------------------------------

Anstatt die existierenden Abhängigkeiten oder gar den Datenfluß genau
zu bestimmen, kann man die Abhängigkeitsanalyse auch als
Entscheidungsproblem betrachten: ``Gibt es Instanzen zweier
Statements, so daß diese Instanzen abhängig voneinander sind?''

Man ist in diesem Fall nicht an den Instanzen interessiert, sondern
nur noch an der \emph{Abhängigkeit zwischen Statements} mit einem
vorgegebenen Richtungsvektor.

Grund: Die NP-harte ganzzahlig lineare Programmierung soll aus
Rechenzeitgründen durch (semi-exakte) Heuristiken ersetzt werden.
Idee: Algorithmus sagt ``unabhängig'', dann ist das garantiert,
ansonsten gehen wir (pessimistischerweise) von einer Abhängigkeit aus.

Wir werden im folgenden eine Auswahl an solchen Heuristiken
vorstellen.


\subsection{GCD-Test \cite{Ban93}}
%------------------------------------------------------------
Eindimensionale Arrays: Seien $X(a_1*i_1+\cdots+a_m*i_m+a_0)$ und
$X(b_1*i_1+\cdots+b_n*i_n+b_0)$ die zu untersuchenden Arrayzugriffe.
Wenn gcd($a_1,\cdots,a_m,b_1,\cdots,b_n$) die Differenz $(b_0-a_0)$
nicht teilt, dann kann es die vermutete Abhängigkeit nicht geben
(Kapitel 3, Punkt 2.(g)).

\smallskip 

Mehrdimensionale Arrays: Führe den einfachen GCD-Test unabhängig für
alle Gleichungen (=Arraydimensionen) durch. Unabhängig, sobald
unabhängig als Resultat für irgendeine Gleichung.

\smallskip

Verallgemeinerter gcd-Test: Berechne die in Kapitel 3, Punkt 2.(i)
angegebene Existenz von $t$, stoppe aber dann mit der genauen
Berechnung der Abhängigkeiten. (Damit werden auch die Räume nicht
überprüft.)  Dies garantiert die gleichzeitige Erfüllung aller
GCD-Tests für sämtliche Arraydimensionen.


\subsection{Separability-Test (\cite{Zima90}, S. 149 ff.)}
%------------------------------------------------------------

Voraussetzung: je Gleichung kommt nur eine Schleifenvariable vor.  Der
Test ist exakt und stellt im wesentlichen eine optimierte, d.h., auf die
Voraussetzung zugeschnittene Version der allgemeinen Lösung dar.


\subsection{Two-Variable-Exact-Test (\cite{Wol95}, S. 238  f.)}
%------------------------------------------------------------

Voraussetzung: jede Gleichung hat maximal zwei Variablen (z.B.,
eindimensionaler Indexraum). Der Test ist exakt und stellt
``vorberechnete'' Lösungsmuster für die gemäß Voraussetzung
zugeschnittene Lösung dar. Vgl. auch \cite{Ban93}, S. 66 ff.


\subsection{Extreme-Value-Test (\cite{Wol95}, S. 236   ff.)} 
% Bounds-Test ?? oder 
%------------------------------------------------------------

Grobidee: Die Unter- bzw. Obergrenzen werden für die Schleifenindizes in
den Arrayausdrücken substituiert. Wenn Überlagerung auftreten kann, dann
wird von einer Abhängigkeit ausgegangen. Etwas genauer:

Eindimensionale Arrays, zunächst eine Schleife: Setzt in die
Konflikt-Gleichung die Variablengrenzen für $i_s$ und $i_t$ so ein, daß
der Wertebereich des Variablenteils der Konfliktgleichung abgeschätzt
wird (primitive Maximierung/Minimierung), und testet dann, ob die
Konstante im Wertebereich liegt.

Verallgemeinerung auf mehrere Schleifen: Wenn Test auf $(*,*,\cdots)$
nicht reicht, dann Aufteilen in $(<,*,\cdots)$, $(=,*,\cdots)$ und
$(>,*,\cdots)$. Idee: $<$, $=$ und $>$ schränken die erlaubten Werte für 
die Indizes $i_s$ und $i_t$ in der aktuellen Schleifendimension ein (im
Bsp. Dim. 1). Damit: für jeden der drei Fälle neu testen und ggfs. in
die nächsten Dimensionen weiterverfeinern.

%\newpage
\paragraph{Variante: Bounds-Test}
Führe die Abschätzung nicht auf der in Normalform gebrachten
Konflikt-Gleichung durch, sondern mache die Abschätzung auf den beiden
Array-Zugriffen separat und teste dann auf Überlappung. Vorteil: die
Semantik ist klarer, was eine verbesserte von-Hand Analyser erlaubt
(s. Übung). 

\subsection{Omega-Test (\cite{Pugh95a})}
%------------------------------------------------------------

\def\MOD{\widehat{\textrm{\ mod\ }}}
Der Omega-Test kombiniert ein eigenständiges Eliminationsverfahren für
ganzzahlige Gleichungen mit einer Erweiterung des Fourier-Motzkin
Verfahrens. 

\begin{enumerate}
\item Wenn in einer Gleichung ein Koeffizient einer Variablen
  betragsmäßig gleich eins ist, dann löse nach dieser Variablen auf
  und setze sie in allen anderen Gleichungen ein. Dadurch reduziert
  sich die Zahl der Gleichungen um eins. Gehe zu 1.
\item Ansonsten: 
  \begin{enumerate}
  \item Sei $k$ der Index der Variablen mit dem betragsmäßig kleinsten
    Koeffizienten $|a_k|$ mit $a_k\not=0$.
  \item Setze $m:= |a_k|+1$.
  \item Mit der Definition $$a\MOD b = a - b *
    \left\lfloor {a\over b} + {1 \over 2}\right \rfloor$$
    berechne die Substitution $$x_k = -sign(a_k)*m*\sigma +
    \sum_{i\in V\backslash\{k\}} sign(a_k)*(a_i \MOD m) * x_i$$
    und die daraus resultierende Gleichung
    $$-|a_k|\sigma + \sum_{i\in V\backslash\{k\}}\left(\left\lfloor{a_i\over
        m} + {1\over 2}\right\rfloor + (a_i\MOD m)\right) * x_i = 0,$$
    wobei $\sigma$ eine neue Variable ist, die $x_k$ ersetzt.
    
    Folge: Die nicht-ersetzten Variablen haben echt kleinere
    Koeffizienten (max. 2/3 des ursprünglichen Wertes), wodurch nach
    einigen Iterationen Koeffizienten vom Betrag eins entstehen.
  \item Das neue System entsteht, indem man die Gleichung, in der $a_k$
    steht, durch die soeben berechnete Gleichung ersetzt und in allen
    anderen (Un-)Gleichungen $x_k$ durch den soeben berechneten Ausdruck 
    für die Substitution ersetzt (und dann vereinfacht).
  \item Falls noch Gleichungen vorhanden sind, gehe zu 1. \\
    Ansonsten gibt es nur noch Ungleichungen!
  \end{enumerate}
\item Bei widersprüchlichen Ungleichungen: Unlösbar. Stop.
\item Bei gegengleichen Ungleichungen: behandle sie als Gleichung.
  (Aus Effizienzgründen beim Suchen nach gegengleichen Ungleichungen
  auch gleich: eliminiere trivial redundante Ungleichungen.)
\item Falls nun höchtens eine Variable: Ganzzahlig lösbar. Stop.
\item Sonst: Dimensionsreduktion durch Fourier-Motzkin. Achtung:
  ganzzahlige Variante:
  \begin{enumerate}
  \item Wähle eine geeignete Variable zur Elimination aus
    (berücksichtige ``exakte Schatten'', kombinatorische
    Explosionsvermeidung bei der Paar-Bildung, kleine Koeffizienten).
  \item Berechne mit FM den ``reellen Schatten'': für jedes der Paare
    $a*x\leq \alpha$ und $b*x\geq \beta$ eliminiere $x$ durch $b*\alpha - a*\beta \geq 0$.
  \item Wenn keine ganzzahlige Lösung im reellen Schatten, dann
      ganzzahlig unlösbar. Stop.
  \item Berechne den ``dunklen Schatten'' mit FM aus den Ungleichungen
    $b*\alpha - a*\beta \geq (a\!-\!1)*(b\!-\!1)$ für jedes der Paare
    $a*x\leq \alpha$ und $b*x\geq \beta$. [Anmerkung: $a*(x\!+\!1)\leq \alpha$ und
    $b*(x\!-\!1)\geq \beta$, also umgeformt $b*\alpha - a*\beta \geq 2*a*b$,
    produzieren einen ``noch dunkleren Schatten''.] 
  \item Wenn ganzzahlige Lösungen im dunklen Schatten, dann ganzzahlig
    lösbar. Stop.
  \item Wenn reeller und dunkler Schatten identisch (\emph{exakte
      Projektion}), dann siehe Lösbarkeit am reellen Schatten -- etwa
    für $a=1$ oder $b=1$.
  \item Ansonsten: Teste Lösbarkeit in der folgenden Serie (wegen
    variablem $i$ und variabler Untergrenze) von Problemen: Füge zum
    Ursprungsproblem die Gleichung $b*x=\beta + i$ hinzu, wobei
    $\beta\leq b*x$ eine Untergrenze von $x$ ist und, für den
    größten in einer oberen Grenze für $x$ vorkommenden Koeffizienten
    $a$, $i$ in folgendem Intervall liegt: $0\leq i\leq
    \left\lfloor{a*b-a-b\over a}\right\rfloor$.  Lösbarkeit des
    Ursprungssystems gdw. mindestens ein Element der Serie lösbar.
  \end{enumerate}
\end{enumerate}



Anmerkung: Neben der Entscheidungs-Variante gibt es auch eine
Lösungsvariante, auch für parametrische Probleme.


%% \subsection{I-Test}
%------------------------------------------------------------



\subsection{Kombinationen}
%------------------------------------------------------------

Natürlich kann man beliebige Heuristiken miteinander kombinieren, um
die Präzision zu erhöhen. Etwa: Falls Separability-Test anwendbar,
dann berechne mit diesem ein exaktes Ergebnis; ansonsten gehen von
Abhängigkeit aus, wenn weder der einfache GCD Test noch der
Bounds-Test die Abhängigkeit ausschließen können.

Die Kombination von gcd-Test und Extreme-Value-Test, angewandt auf jede
einzelne Array-Koordinate und auf die Linearisierung des Arrayzugriffs
(etwa durch zeilenweise Speicherung des Arrays) wurde aufgrund der
Einfachheit dieser Tests früher in Compilern häufig
verwendet. Heutzutage verwendet man eher den verallgemeinerten gcd-Test
und die Fourier-Motzkin-Projektion, sofern man nicht gleich die exakte
Berechnung (ohne Optimierung) durchführt. (Vgl. \cite{Wol95}, S. 249)



\def\ins{\hspace{.5cm}}
